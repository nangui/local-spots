# 🚀 Règles de Déploiement - LocalSpots

## 🌍 Environnements

### Environnements Supportés
- **Development** : Local avec hot reload et outils de debug
- **Staging** : Pré-production pour tests et validation
- **Production** : Environnement de production avec optimisations

### Variables d'Environnement par Environnement
```bash
# .env.development
NODE_ENV=development
HOST=localhost
PORT=3333
DB_DATABASE=local_spots_dev
DEBUG=true

# .env.staging
NODE_ENV=staging
HOST=0.0.0.0
PORT=3333
DB_DATABASE=local_spots_staging
DEBUG=false

# .env.production
NODE_ENV=production
HOST=0.0.0.0
PORT=3333
DB_DATABASE=local_spots_prod
DEBUG=false
CACHE_VIEWS=true
```

## 🐳 Configuration Docker

### Dockerfile Production
```dockerfile
FROM node:18-alpine AS builder
WORKDIR /app
COPY package*.json ./
RUN npm ci --only=production
COPY . .
RUN npm run build

FROM node:18-alpine AS runtime
WORKDIR /app
COPY --from=builder /app/build ./build
COPY --from=builder /app/package*.json ./
RUN npm ci --only=production
EXPOSE 3333
CMD ["node", "build/bin/server.js"]
```

### Docker Compose Production
```yaml
version: '3.8'
services:
  app:
    build: .
    ports:
      - "3333:3333"
    environment:
      - NODE_ENV=production
      - DB_HOST=postgres
    depends_on:
      - postgres
      - redis
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3333/health"]
      interval: 30s
      timeout: 10s
      retries: 3

  postgres:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=local_spots
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=${DB_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
    restart: unless-stopped

  redis:
    image: redis:7-alpine
    restart: unless-stopped
```

## 🔒 Sécurité Production

### Headers de Sécurité
```typescript
// config/shield.ts
export default shieldConfig({
  xFrame: { enabled: true, action: 'DENY' },
  hsts: { enabled: true, maxAge: '180 days' },
  contentTypeSniffing: { enabled: true },
  xss: { enabled: true, mode: 'block' },
  csp: {
    enabled: true,
    directives: {
      defaultSrc: ["'self'"],
      scriptSrc: ["'self'"],
      styleSrc: ["'self'", "'unsafe-inline'"],
      imgSrc: ["'self'", "data:", "https:"],
      connectSrc: ["'self'"],
      fontSrc: ["'self'"],
      objectSrc: ["'none'"],
      mediaSrc: ["'none'"],
      frameSrc: ["'none'"]
    }
  }
})
```

### Configuration SSL/TLS
```nginx
server {
    listen 443 ssl http2;
    server_name yourdomain.com;
    
    ssl_certificate /etc/letsencrypt/live/yourdomain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/yourdomain.com/privkey.pem;
    
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512;
    ssl_prefer_server_ciphers off;
    
    location / {
        proxy_pass http://localhost:3333;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }
}
```

## 📊 Monitoring et Logging

### Configuration des Logs
```typescript
// config/logger.ts
export default loggerConfig({
  enabled: true,
  name: 'local-spots',
  level: Env.get('LOG_LEVEL', 'info'),
  prettyPrint: Env.get('NODE_ENV') === 'development',
  destination: Env.get('NODE_ENV') === 'production' ? 'file' : 'console',
  file: {
    filename: 'logs/app.log',
    maxSize: '20m',
    maxFiles: '14d'
  }
})
```

### Health Check Endpoint
```typescript
// start/routes.ts
Route.get('/health', async ({ response }) => {
  const health = {
    status: 'healthy',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
    memory: process.memoryUsage(),
    database: await Database.healthCheck()
  }
  
  const isHealthy = health.database && health.memory.heapUsed < 500 * 1024 * 1024
  
  return response.status(isHealthy ? 200 : 503).json(health)
})
```

### Métriques Prometheus
```typescript
// app/controllers/metrics_controller.ts
export default class MetricsController {
  async index({ response }: HttpContext) {
    const metrics = {
      http_requests_total: await this.getRequestCount(),
      http_request_duration_seconds: await this.getRequestDuration(),
      database_connections: await this.getDatabaseConnections(),
      memory_usage_bytes: process.memoryUsage()
    }
    
    return response.json(metrics)
  }
}
```

## 🔄 CI/CD Pipeline

### GitHub Actions Workflow
```yaml
name: Deploy to Production

on:
  push:
    branches: [main]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
          cache: 'npm'
      - run: npm ci
      - run: npm run lint
      - run: npm run typecheck
      - run: npm test
      - run: npm run build

  deploy:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - name: Deploy to server
        uses: appleboy/ssh-action@master
        with:
          host: ${{ secrets.HOST }}
          username: ${{ secrets.USERNAME }}
          key: ${{ secrets.SSH_KEY }}
          script: |
            cd /var/www/local-spots
            git pull origin main
            npm ci --production
            npm run build
            pm2 restart local-spots
```

### Scripts de Déploiement
```bash
#!/bin/bash
# scripts/deploy.sh

set -e

echo "🚀 Starting deployment..."

# Pull latest changes
git pull origin main

# Install dependencies
npm ci --production

# Build application
npm run build

# Run migrations
node ace migration:run --force

# Restart application
pm2 restart local-spots

# Health check
sleep 5
curl -f http://localhost:3333/health || exit 1

echo "✅ Deployment completed successfully!"
```

## 📈 Performance et Optimisation

### Configuration PM2
```javascript
// ecosystem.config.js
module.exports = {
  apps: [{
    name: 'local-spots',
    script: './build/bin/server.js',
    instances: 'max',
    exec_mode: 'cluster',
    autorestart: true,
    watch: false,
    max_memory_restart: '1G',
    env: {
      NODE_ENV: 'production',
      PORT: 3333
    },
    env_production: {
      NODE_ENV: 'production',
      PORT: 3333
    }
  }]
}
```

### Optimisations Node.js
```bash
# .env.production
NODE_OPTIONS="--max-old-space-size=2048 --optimize-for-size"
UV_THREADPOOL_SIZE=64
```

### Configuration Redis
```typescript
// config/redis.ts
export default redisConfig({
  connection: 'main',
  connections: {
    main: {
      host: Env.get('REDIS_HOST', 'localhost'),
      port: Env.get('REDIS_PORT', 6379),
      password: Env.get('REDIS_PASSWORD'),
      db: Env.get('REDIS_DB', 0),
      keyPrefix: 'local_spots:'
    }
  }
})
```

## 🚨 Gestion des Incidents

### Plan de Rollback
```bash
#!/bin/bash
# scripts/rollback.sh

echo "🔄 Starting rollback..."

# Get previous version
PREVIOUS_VERSION=$(git log --oneline -2 | tail -1 | cut -d' ' -f1)

# Checkout previous version
git checkout $PREVIOUS_VERSION

# Install and build
npm ci --production
npm run build

# Restart application
pm2 restart local-spots

echo "✅ Rollback completed to version $PREVIOUS_VERSION"
```

### Monitoring des Erreurs
```typescript
// app/exceptions/handler.ts
export default class ExceptionHandler extends BaseExceptionHandler {
  async handle(error: any, ctx: HttpContext) {
    if (error.status === 500) {
      // Log critical errors
      logger.error('Critical error occurred', {
        error: error.message,
        stack: error.stack,
        url: ctx.request.url(),
        method: ctx.request.method(),
        userAgent: ctx.request.header('user-agent'),
        ip: ctx.request.ip()
      })
      
      // Send alert to monitoring service
      await this.sendAlert(error, ctx)
    }
    
    return super.handle(error, ctx)
  }
}
```

## 📋 Checklist de Déploiement

### Pré-déploiement
- [ ] Tests passent en local
- [ ] Code review approuvé
- [ ] Variables d'environnement configurées
- [ ] Base de données migrée
- [ ] SSL/HTTPS configuré
- [ ] Monitoring en place

### Post-déploiement
- [ ] Health check OK
- [ ] Logs sans erreurs critiques
- [ ] Performance acceptable
- [ ] Fonctionnalités testées
- [ ] Backup automatique configuré
- [ ] Documentation mise à jour

## 🔮 Évolutions Futures

### Infrastructure as Code
- **Terraform** pour la gestion des ressources cloud
- **Ansible** pour la configuration des serveurs
- **Kubernetes** pour l'orchestration des conteneurs

### Monitoring Avancé
- **Grafana** pour les dashboards
- **Prometheus** pour les métriques
- **ELK Stack** pour l'analyse des logs
- **Sentry** pour le tracking d'erreurs
description:
globs:
alwaysApply: true
---
